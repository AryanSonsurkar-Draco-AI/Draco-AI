<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Draco Assistant</title>
  <style>
    :root {
      --bg-start: #0f0c1f;    /* dark purple */
      --bg-end: #171333;
      --card: #1c1842;
      --accent: #7c4dff;      /* purple */
      --accent-2: #00bfa5;    /* teal */
      --text: #ece8ff;
      --muted: #a7a2c7;
      --line: #2b2753;
    }
    * { box-sizing: border-box; }
    body { font-family: ui-sans-serif, system-ui, Arial, sans-serif; margin: 0; color: var(--text);
      background: linear-gradient(180deg, var(--bg-start), var(--bg-end));
      min-height: 100dvh;
    }
    .wrap { max-width: 1100px; margin: 32px auto; padding: 0 18px; }
    h1 { font-size: 30px; margin: 0 0 10px; letter-spacing: 0.4px; }
    .status { display:flex; align-items:center; gap:8px; color: var(--muted); font-size: 14px; margin-bottom: 14px; }
    .dot { width:10px; height:10px; border-radius:50%; background:#ff5c5c; }
    .dot.on { background:#25ff9b; }
    .card { position:relative; background: var(--card); border: 1px solid var(--line); border-radius: 14px; padding: 16px; box-shadow: 0 2px 10px rgba(0,0,0,.25); }
    .row { display: flex; gap: 10px; }
    .input { display:flex; gap:10px; align-items:center; padding:10px; border-radius: 12px; border:1px solid var(--line); background:#151236; }
    input[type=text] { flex: 1; padding: 12px; border-radius: 10px; border: none; outline: none; background: transparent; color: var(--text); font-size: 15px; }
    .btn { padding: 12px 14px; border-radius: 10px; border: 1px solid var(--accent); background: var(--accent); color: #fff; cursor: pointer; transition: transform .08s ease, box-shadow .15s ease, filter .15s ease; }
    .btn:hover { filter: brightness(.95); transform: translateY(-1px); }
    .btn:disabled { opacity:.55; cursor:not-allowed; filter: grayscale(.3); }
    .chipbar { display:flex; flex-wrap: wrap; gap:8px; margin-top:10px; }
    .chip { padding:8px 12px; border-radius: 999px; border:1px solid var(--line); color:#d9d3ff; background: #17143a; cursor:pointer; }
    .chip:hover { background:#1b1746; }
    .log { margin-top: 16px; max-height: 520px; overflow: auto; padding-right: 4px; }
    .item { background:#151236; border:1px solid var(--line); border-radius: 12px; padding:12px; margin:10px 0; }
    .user { color:#b7a7ff; }
    .bot { color:#9bf0e2; }
    small { color:var(--muted); }
    /* layout: sidebar + main */
    .layout { display:grid; grid-template-columns: 290px 1fr; gap:14px; }
    .side { background: var(--card); border:1px solid var(--line); border-radius:14px; padding:14px; }
    .profile { display:flex; align-items:center; gap:10px; padding:8px; border-bottom:1px solid rgba(111,141,255,.18); }
    .avatar { width:36px; height:36px; border-radius:50%; background:#2a245b; display:grid; place-items:center; color:#eae4ff; border:1px solid var(--line); }
    .meta small { color:var(--muted); display:block; }
    .history { margin-top:12px; max-height: 520px; overflow:auto; }
    .hitem { padding:8px 10px; border-radius:10px; border:1px solid var(--line); margin:8px 0; color:#d9d3ff; background:#151236; cursor:pointer; }
    .hitem:hover { background:#1b1746; }
    .sideActions { display:flex; gap:8px; margin-top:10px; }
    .toggleBar { text-align:right; margin-bottom:8px; }
    .layout.collapsed { grid-template-columns: 0 1fr; }
    .layout.expanded { grid-template-columns: 420px 1fr; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Draco Assistant</h1>
    <div class="status"><span class="dot" id="dot"></span><span id="statusText">Connectingâ€¦</span></div>
    <div class="toggleBar">
      <button class="btn" id="toggleSide">Hide Sidebar</button>
      <button class="btn" id="expandSide">Expand</button>
    </div>
    <div class="layout" id="layout">
      <div class="side" id="sidebar">
        <div class="profile">
          <div class="avatar" id="avatar">U</div>
          <div class="meta">
            <div id="profName">Guest</div>
            <small id="profEmail">Not signed in</small>
          </div>
        </div>
        <div class="sideActions">
          <button class="btn" id="newChat">New Chat</button>
          <button class="btn" id="clearChat">Clear</button>
        </div>
        <div class="history" id="history"></div>
      </div>
      <div class="card">
        <div class="input" style="margin-bottom:10px;">
          <input id="input" type="text" placeholder="Type a command (e.g., open youtube, play music, take note ...)" />
          <button class="btn" id="sendBtn">Send</button>
        </div>
        <div class="row" style="margin-bottom:10px;">
          <button class="btn" id="micBtn">ðŸŽ¤ Speak</button>
          <button class="btn" id="stopSpeakBtn">ðŸ›‘ Stop Voice</button>
        </div>
        <div class="chipbar" id="chips">
          <div class="chip" data-cmd="open youtube">Open YouTube</div>
          <div class="chip" data-cmd="play music">Play Music</div>
          <div class="chip" data-cmd="take note buy milk">Take Note</div>
          <div class="chip" data-cmd="list notes">List Notes</div>
          <div class="chip" data-cmd="system status">System Status</div>
          <div class="chip" data-cmd="search for render deployment guide">Search Web</div>
        </div>
        <div class="log" id="log"></div>
        <small>Tip: Try "open youtube", "play music", "list notes", "remind me to drink water at 19:30"</small>
      </div>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const log = document.getElementById('log');
    const input = document.getElementById('input');
    const sendBtn = document.getElementById('sendBtn');
    const micBtn = document.getElementById('micBtn');
    const stopSpeakBtn = document.getElementById('stopSpeakBtn');
    const dot = document.getElementById('dot');
    const statusText = document.getElementById('statusText');

    let socket = null;
    let user = { logged_in: false, email: null, profile: {} };
    let historyItems = [];
    let chatsList = [];
    try {
      socket = io({ transports: ['websocket', 'polling'], withCredentials: false });
    } catch (e) {
      socket = null;
    }

    function appendItem(text, who='bot') {
      const el = document.createElement('div');
      el.className = 'item';
      el.innerHTML = `<div class="${who}">${text}</div>`;
      log.appendChild(el);
      log.scrollTop = log.scrollHeight;
    }

    function initials(name) {
      if (!name) return 'U';
      const parts = name.trim().split(/\s+/);
      const a = parts[0]?.[0] || '';
      const b = parts[1]?.[0] || '';
      return (a + b).toUpperCase() || 'U';
    }

    function renderProfile() {
      const profName = document.getElementById('profName');
      const profEmail = document.getElementById('profEmail');
      const avatar = document.getElementById('avatar');
      const name = (user.profile && user.profile.name) ? user.profile.name : (user.logged_in ? 'You' : 'Guest');
      profName.textContent = name;
      profEmail.textContent = user.logged_in ? (user.email||'') : 'Not signed in';
      avatar.textContent = initials(name);
    }

    function renderHistory() {
      const container = document.getElementById('history');
      if (!container) return;
      container.innerHTML = '';
      // Render chat list with names first
      const list = document.createElement('div');
      (chatsList || []).forEach((c) => {
        const d = document.createElement('div');
        d.className = 'hitem';
        d.textContent = c.name || 'New Chat';
        d.onclick = async () => {
          try {
            await fetch('/api/chats/select', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ chat_id: c.id }) });
            await loadHistory();
          } catch (e) {}
        };
        list.appendChild(d);
      });
      container.appendChild(list);
      // recent messages preview under list
      historyItems.slice(-30).forEach((it) => {
        const text = (it.who === 'user' ? 'You: ' : 'Draco: ') + it.text;
        const d = document.createElement('div');
        d.className = 'hitem';
        d.textContent = text.length > 80 ? text.slice(0, 77) + 'â€¦' : text;
        try { d.title = new Date((it.ts||0)*1000).toLocaleString(); } catch (e) {}
        d.onclick = () => {
          appendItem(it.text, it.who === 'user' ? 'user' : 'bot');
        };
        container.appendChild(d);
      });
    }

    let voiceEnabled = false;
    function speakText(text) {
      try {
        if (!voiceEnabled) return; // gated by user gesture
        window.speechSynthesis.cancel();
        const utter = new SpeechSynthesisUtterance(text);
        utter.rate = 1.0;
        utter.pitch = 1.0;
        utter.lang = 'en-US';
        window.speechSynthesis.speak(utter);
      } catch (e) { /* no-op */ }
    }

    stopSpeakBtn.onclick = () => window.speechSynthesis.cancel();

    async function sendCommand(text) {
      if (!text) return;
      appendItem(text, 'user');
      // Prefer socket if connected
      if (socket && socket.connected) {
        try { socket.emit('user_command', { text }); return; } catch (e) {}
      }
      // Fallback to HTTP
      try {
        const r = await fetch('/api/command', {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text })
        });
        const data = await r.json();
        if (data && data.action === 'open_url' && data.url) {
          try { window.open(data.url, '_blank'); } catch (e) {}
        }
        const t = (data && data.text) ? String(data.text) : (data && data.error) ? String(data.error) : 'No response';
        if (t) {
          appendItem(t, 'bot');
          speakText(t);
        }
      } catch (e) {
        appendItem('Request failed. Please retry.', 'bot');
      }
    }

    async function loadMe() {
      try {
        const r = await fetch('/me');
        const d = await r.json();
        user = d || { logged_in:false };
        if (!user.logged_in) {
          // guest mode is allowed when directly opening this page
          appendItem('Guest mode: your chats won\'t be saved. Sign in to sync.', 'bot');
          return;
        }
        appendItem('Signed in as ' + user.email, 'bot');
        renderProfile();
        await loadHistory();
        await maybeRunOnboarding();
      } catch (e) { /* ignore */ }
    }

    async function loadHistory() {
      try {
        const [h, l] = await Promise.all([
          fetch('/api/chat_history'),
          fetch('/api/chats')
        ]);
        if (!h.ok) return;
        const d = await h.json();
        if (!d.ok) return;
        historyItems = d.items || [];
        if (l.ok) {
          const dl = await l.json();
          chatsList = (dl && dl.ok) ? dl.chats || [] : [];
        }
        historyItems.slice(-20).forEach(it => {
          appendItem(it.text, it.who === 'user' ? 'user' : 'bot');
        });
        renderHistory();
      } catch (e) {}
    }

    async function maybeRunOnboarding() {
      if (!user.logged_in) return;
      try {
        const r = await fetch('/api/profile');
        if (!r.ok) return;
        const d = await r.json();
        if (!d.ok) return;
        const p = d.profile || {};
        const needed = [];
        if (!p.name) needed.push('name');
        if (!p.language) needed.push('language');
        if (!p.interests) needed.push('interests');
        if (needed.length === 0) return;
        appendItem('Let\'s personalize your experience. I\'ll ask a few quick questions.', 'bot');
        const updates = {};
        if (needed.includes('name')) {
          const v = prompt('What should I call you?');
          if (v) updates.name = v.trim();
        }
        if (needed.includes('language')) {
          const v = prompt('Preferred language (e.g., English, Hindi)?');
          if (v) updates.language = v.trim();
        }
        if (needed.includes('interests')) {
          const v = prompt('Your interests (comma-separated)?');
          if (v) updates.interests = v.trim();
        }
        if (Object.keys(updates).length) {
          await fetch('/api/profile', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(updates) });
          appendItem('Thanks! I\'ll use that to tailor my replies.', 'bot');
        }
      } catch (e) {}
    }

    sendBtn.onclick = () => {
      const val = (input.value || '').trim();
      if (!val) return;
      sendCommand(val);
      input.value = '';
      input.focus();
    };

    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') sendBtn.click();
    });

    if (socket) {
      socket.on('connect', () => {
        appendItem('Connected to Draco!', 'bot');
        dot.classList.add('on');
        statusText.textContent = 'Online';
        sendBtn.disabled = false;
        micBtn.disabled = false;
        // Load user state/history after connection
        loadMe();
      });
      socket.on('disconnect', () => {
        appendItem('Disconnected. Using HTTP fallbackâ€¦', 'bot');
        dot.classList.remove('on');
        statusText.textContent = 'HTTP mode';
      });
      socket.on('draco_response', (data) => {
        if (!data) return;
        if (data.action === 'open_url' && data.url) {
          try { window.open(data.url, '_blank'); } catch (e) {}
        }
        const text = (data && data.text) ? String(data.text) : '';
        if (text) {
          appendItem(text, 'bot');
          speakText(text);
        }
      });
    } else {
      statusText.textContent = 'HTTP mode';
    }

    // Enable speech on first interaction (autoplay policies)
    document.addEventListener('click', () => {
      if (!voiceEnabled) {
        try { window.speechSynthesis.resume(); } catch (e) {}
        voiceEnabled = true;
      }
    }, { once: true });

    // Browser voice input (Web Speech API) â€“ best effort
    let recognition = null;
    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognition = new SR();
      recognition.lang = 'en-IN';
      recognition.interimResults = false;
      recognition.maxAlternatives = 1;
      recognition.onresult = (event) => {
        const transcript = event.results[0][0].transcript;
        input.value = transcript;
        sendBtn.click();
      };
      recognition.onerror = (e) => appendItem('Mic error: ' + e.error, 'bot');
      recognition.onend = () => micBtn.disabled = false;
    }

    micBtn.onclick = () => {
      if (!recognition) {
        appendItem('Speech recognition not supported in this browser.', 'bot');
        return;
      }
      try {
        micBtn.disabled = true;
        recognition.start();
      } catch (e) {
        micBtn.disabled = false;
      }
    };

    // Quick chips
    document.getElementById('chips').addEventListener('click', (e) => {
      const t = e.target.closest('.chip');
      if (!t) return;
      const cmd = t.getAttribute('data-cmd');
      input.value = cmd;
      sendBtn.click();
    });
    // Sidebar controls
    const layoutEl = document.getElementById('layout');
    const toggleSide = document.getElementById('toggleSide');
    const expandSide = document.getElementById('expandSide');
    const newChatBtn = document.getElementById('newChat');
    const clearChatBtn = document.getElementById('clearChat');
    let collapsed = false; let expanded = false;
    toggleSide.onclick = () => {
      collapsed = !collapsed;
      layoutEl.classList.toggle('collapsed', collapsed);
      toggleSide.textContent = collapsed ? 'Show Sidebar' : 'Hide Sidebar';
    };
    expandSide.onclick = () => {
      expanded = !expanded;
      layoutEl.classList.toggle('expanded', expanded);
      expandSide.textContent = expanded ? 'Shrink' : 'Expand';
    };
    newChatBtn.onclick = async () => {
      try { await fetch('/api/chats/new', { method:'POST' }); await loadHistory(); } catch (e) {}
    };
    clearChatBtn.onclick = async () => {
      try { await fetch('/api/chats/clear', { method:'POST' }); historyItems = []; renderHistory(); } catch (e) {}
    };
    // Update sidebar in guest mode too
    renderProfile();
  </script>
</body>
</html>


